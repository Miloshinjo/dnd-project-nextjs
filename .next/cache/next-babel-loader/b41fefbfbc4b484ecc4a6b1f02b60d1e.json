{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { mutationField } from '@nexus/schema';\nimport errors from '../../../utils/errors';\nimport { handleError } from '../../../utils/helpers';\nexport const createCharacter = mutationField('createCharacter', {\n  type: 'Character',\n  args: {\n    character: 'CharacterCreateInput'\n  },\n\n  async resolve(_parent, {\n    character\n  }, {\n    prisma,\n    userId\n  }) {\n    if (!character) {\n      return handleError(errors.serverError);\n    }\n\n    try {\n      const {\n        klassId\n      } = character,\n            restCharacter = _objectWithoutProperties(character, [\"klassId\"]);\n\n      const createdCharacter = await prisma.character.create({\n        data: _objectSpread(_objectSpread({}, restCharacter), {}, {\n          user: {\n            connect: {\n              id: userId\n            }\n          },\n          klass: {\n            connect: {\n              id: klassId\n            }\n          }\n        })\n      });\n      return createdCharacter;\n    } catch (err) {\n      console.log(err);\n      return handleError(errors.badCharacterData);\n    }\n  }\n\n});\nexport const updateCharacter = mutationField('updateCharacter', {\n  type: 'Character',\n  args: {\n    character: 'CharacterUpdateInput'\n  },\n\n  async resolve(_parent, {\n    character\n  }, {\n    prisma\n  }) {\n    if (!character) {\n      return handleError(errors.serverError);\n    }\n\n    try {\n      const {\n        klassId,\n        skillId\n      } = character,\n            restCharacter = _objectWithoutProperties(character, [\"klassId\", \"skillId\"]);\n\n      if (!character) {\n        return handleError(errors.serverError);\n      }\n\n      if (skillId) {\n        const skills = await prisma.character.findOne({\n          where: {\n            id: character.id\n          }\n        }).skills();\n        const targetSkill = skills.find(skill => skill.id === skillId);\n        const action = targetSkill ? 'disconnect' : 'connect';\n        const updatedCharacter = await prisma.character.update({\n          where: {\n            id: character.id\n          },\n          data: _objectSpread(_objectSpread({}, restCharacter), {}, {\n            skills: {\n              [action]: {\n                id: skillId\n              }\n            }\n          })\n        });\n        return updatedCharacter;\n      }\n\n      if (klassId) {\n        const updatedCharacter = await prisma.character.update({\n          where: {\n            id: character.id\n          },\n          data: _objectSpread(_objectSpread({}, restCharacter), {}, {\n            klass: {\n              connect: {\n                id: klassId\n              }\n            }\n          })\n        });\n        return updatedCharacter;\n      }\n\n      const updatedCharacter = await prisma.character.update({\n        where: {\n          id: character.id\n        },\n        data: restCharacter\n      });\n      return updatedCharacter;\n    } catch (err) {\n      console.log(err);\n      return handleError(errors.badCharacterData);\n    }\n  }\n\n});\nexport const deleteCharacter = mutationField('deleteCharacter', {\n  type: 'Character',\n  nullable: true,\n  args: {\n    character: 'CharacterDeleteInput'\n  },\n\n  async resolve(_parent, {\n    character\n  }, {\n    prisma\n  }) {\n    if (!character) {\n      return handleError(errors.serverError);\n    }\n\n    return prisma.character.delete({\n      where: {\n        id: character.id\n      }\n    });\n  }\n\n});\nexport const learnSpell = mutationField('learnSpell', {\n  type: 'Character',\n  args: {\n    character: 'CharacterEditSpellInput'\n  },\n\n  async resolve(_parent, {\n    character\n  }, {\n    prisma\n  }) {\n    if (!character) {\n      return handleError(errors.serverError);\n    }\n\n    try {\n      const updatedCharacter = await prisma.character.update({\n        where: {\n          id: character.id\n        },\n        data: {\n          spells: {\n            connect: {\n              id: character.spellId\n            }\n          }\n        }\n      });\n      return updatedCharacter;\n    } catch (err) {\n      console.log(err);\n      return handleError(errors.badCharacterData);\n    }\n  }\n\n});\nexport const forgetSpell = mutationField('forgetSpell', {\n  type: 'Character',\n  args: {\n    character: 'CharacterEditSpellInput'\n  },\n\n  async resolve(_parent, {\n    character\n  }, {\n    prisma\n  }) {\n    if (!character) {\n      return handleError(errors.serverError);\n    }\n\n    try {\n      const updatedCharacter = await prisma.character.update({\n        where: {\n          id: character.id\n        },\n        data: {\n          spells: {\n            disconnect: {\n              id: character.spellId\n            }\n          }\n        }\n      });\n      return updatedCharacter;\n    } catch (err) {\n      console.log(err);\n      return handleError(errors.badCharacterData);\n    }\n  }\n\n});\nexport const prepareSpell = mutationField('prepareSpell', {\n  type: 'Character',\n  args: {\n    character: 'CharacterEditSpellInput'\n  },\n\n  async resolve(_parent, {\n    character\n  }, {\n    prisma\n  }) {\n    if (!character) {\n      return handleError(errors.serverError);\n    }\n\n    try {\n      const updatedCharacter = await prisma.character.update({\n        where: {\n          id: character.id\n        },\n        data: {\n          preparedSpells: {\n            connect: {\n              id: character.spellId\n            }\n          }\n        }\n      });\n      return updatedCharacter;\n    } catch (err) {\n      console.log(err);\n      return handleError(errors.badCharacterData);\n    }\n  }\n\n});\nexport const unprepareSpell = mutationField('unprepareSpell', {\n  type: 'Character',\n  args: {\n    character: 'CharacterEditSpellInput'\n  },\n\n  async resolve(_parent, {\n    character\n  }, {\n    prisma\n  }) {\n    if (!character) {\n      return handleError(errors.serverError);\n    }\n\n    try {\n      const updatedCharacter = await prisma.character.update({\n        where: {\n          id: character.id\n        },\n        data: {\n          preparedSpells: {\n            disconnect: {\n              id: character.spellId\n            }\n          }\n        }\n      });\n      return updatedCharacter;\n    } catch (err) {\n      console.log(err);\n      return handleError(errors.badCharacterData);\n    }\n  }\n\n});\nexport const addSubclass = mutationField('addSubclass', {\n  type: 'Character',\n  args: {\n    character: 'CharacterAddSubclassInputType'\n  },\n\n  async resolve(_parent, {\n    character\n  }, {\n    prisma\n  }) {\n    if (!character) {\n      return handleError(errors.serverError);\n    }\n\n    try {\n      const updatedCharacter = await prisma.character.update({\n        where: {\n          id: character.id\n        },\n        data: {\n          subclass: {\n            connect: {\n              id: character.subclassId\n            }\n          }\n        }\n      });\n      return updatedCharacter;\n    } catch (err) {\n      console.log(err);\n      return handleError(errors.badCharacterData);\n    }\n  }\n\n});","map":{"version":3,"sources":["/Users/milosdzeletovic/projects/me/dnd-armory/dnd-armory-next/server/types/resolvers/mutations/character.ts"],"names":["mutationField","errors","handleError","createCharacter","type","args","character","resolve","_parent","prisma","userId","serverError","klassId","restCharacter","createdCharacter","create","data","user","connect","id","klass","err","console","log","badCharacterData","updateCharacter","skillId","skills","findOne","where","targetSkill","find","skill","action","updatedCharacter","update","deleteCharacter","nullable","delete","learnSpell","spells","spellId","forgetSpell","disconnect","prepareSpell","preparedSpells","unprepareSpell","addSubclass","subclass","subclassId"],"mappings":"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","sourcesContent":["import { mutationField } from '@nexus/schema'\n\nimport errors from '../../../utils/errors'\nimport { handleError } from '../../../utils/helpers'\n\nexport const createCharacter = mutationField('createCharacter', {\n  type: 'Character',\n  args: {\n    character: 'CharacterCreateInput',\n  },\n  async resolve(_parent, { character }, { prisma, userId }) {\n    if (!character) {\n      return handleError(errors.serverError)\n    }\n\n    try {\n      const { klassId, ...restCharacter } = character\n\n      const createdCharacter = await prisma.character.create({\n        data: {\n          ...restCharacter,\n          user: { connect: { id: userId } },\n          klass: { connect: { id: klassId } },\n        },\n      })\n\n      return createdCharacter\n    } catch (err) {\n      console.log(err)\n      return handleError(errors.badCharacterData)\n    }\n  },\n})\n\nexport const updateCharacter = mutationField('updateCharacter', {\n  type: 'Character',\n  args: {\n    character: 'CharacterUpdateInput',\n  },\n  async resolve(_parent, { character }, { prisma }) {\n    if (!character) {\n      return handleError(errors.serverError)\n    }\n\n    try {\n      const { klassId, skillId, ...restCharacter } = character\n\n      if (!character) {\n        return handleError(errors.serverError)\n      }\n\n      if (skillId) {\n        const skills = await prisma.character\n          .findOne({\n            where: {\n              id: character.id,\n            },\n          })\n          .skills()\n\n        const targetSkill = skills.find((skill) => skill.id === skillId)\n\n        const action = targetSkill ? 'disconnect' : 'connect'\n\n        const updatedCharacter = await prisma.character.update({\n          where: {\n            id: character.id,\n          },\n          data: {\n            ...restCharacter,\n            skills: { [action]: { id: skillId } },\n          },\n        })\n\n        return updatedCharacter\n      }\n\n      if (klassId) {\n        const updatedCharacter = await prisma.character.update({\n          where: {\n            id: character.id,\n          },\n          data: {\n            ...restCharacter,\n            klass: { connect: { id: klassId } },\n          },\n        })\n\n        return updatedCharacter\n      }\n\n      const updatedCharacter = await prisma.character.update({\n        where: {\n          id: character.id,\n        },\n        data: restCharacter,\n      })\n\n      return updatedCharacter\n    } catch (err) {\n      console.log(err)\n      return handleError(errors.badCharacterData)\n    }\n  },\n})\n\nexport const deleteCharacter = mutationField('deleteCharacter', {\n  type: 'Character',\n  nullable: true,\n  args: {\n    character: 'CharacterDeleteInput',\n  },\n  async resolve(_parent, { character }, { prisma }) {\n    if (!character) {\n      return handleError(errors.serverError)\n    }\n\n    return prisma.character.delete({\n      where: {\n        id: character.id,\n      },\n    })\n  },\n})\n\nexport const learnSpell = mutationField('learnSpell', {\n  type: 'Character',\n  args: {\n    character: 'CharacterEditSpellInput',\n  },\n  async resolve(_parent, { character }, { prisma }) {\n    if (!character) {\n      return handleError(errors.serverError)\n    }\n\n    try {\n      const updatedCharacter = await prisma.character.update({\n        where: {\n          id: character.id,\n        },\n        data: {\n          spells: { connect: { id: character.spellId } },\n        },\n      })\n\n      return updatedCharacter\n    } catch (err) {\n      console.log(err)\n      return handleError(errors.badCharacterData)\n    }\n  },\n})\n\nexport const forgetSpell = mutationField('forgetSpell', {\n  type: 'Character',\n  args: {\n    character: 'CharacterEditSpellInput',\n  },\n  async resolve(_parent, { character }, { prisma }) {\n    if (!character) {\n      return handleError(errors.serverError)\n    }\n\n    try {\n      const updatedCharacter = await prisma.character.update({\n        where: {\n          id: character.id,\n        },\n        data: {\n          spells: { disconnect: { id: character.spellId } },\n        },\n      })\n\n      return updatedCharacter\n    } catch (err) {\n      console.log(err)\n      return handleError(errors.badCharacterData)\n    }\n  },\n})\n\nexport const prepareSpell = mutationField('prepareSpell', {\n  type: 'Character',\n  args: {\n    character: 'CharacterEditSpellInput',\n  },\n  async resolve(_parent, { character }, { prisma }) {\n    if (!character) {\n      return handleError(errors.serverError)\n    }\n\n    try {\n      const updatedCharacter = await prisma.character.update({\n        where: {\n          id: character.id,\n        },\n        data: {\n          preparedSpells: { connect: { id: character.spellId } },\n        },\n      })\n\n      return updatedCharacter\n    } catch (err) {\n      console.log(err)\n      return handleError(errors.badCharacterData)\n    }\n  },\n})\n\nexport const unprepareSpell = mutationField('unprepareSpell', {\n  type: 'Character',\n  args: {\n    character: 'CharacterEditSpellInput',\n  },\n  async resolve(_parent, { character }, { prisma }) {\n    if (!character) {\n      return handleError(errors.serverError)\n    }\n\n    try {\n      const updatedCharacter = await prisma.character.update({\n        where: {\n          id: character.id,\n        },\n        data: {\n          preparedSpells: { disconnect: { id: character.spellId } },\n        },\n      })\n\n      return updatedCharacter\n    } catch (err) {\n      console.log(err)\n      return handleError(errors.badCharacterData)\n    }\n  },\n})\n\nexport const addSubclass = mutationField('addSubclass', {\n  type: 'Character',\n  args: {\n    character: 'CharacterAddSubclassInputType',\n  },\n  async resolve(_parent, { character }, { prisma }) {\n    if (!character) {\n      return handleError(errors.serverError)\n    }\n\n    try {\n      const updatedCharacter = await prisma.character.update({\n        where: {\n          id: character.id,\n        },\n        data: {\n          subclass: { connect: { id: character.subclassId } },\n        },\n      })\n\n      return updatedCharacter\n    } catch (err) {\n      console.log(err)\n      return handleError(errors.badCharacterData)\n    }\n  },\n})\n"]},"metadata":{},"sourceType":"module"}