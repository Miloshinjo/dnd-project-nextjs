{"ast":null,"code":"import { mutationField, stringArg } from '@nexus/schema';\nimport bcrypt from 'bcryptjs';\nimport errors from '../../../utils/errors';\nimport { handleError } from '../../../utils/helpers';\nimport { generateAccessToken } from '../../../utils/helpers';\nexport const signup = mutationField('signup', {\n  type: 'AuthPayload',\n  args: {\n    user: 'UserCreateInput'\n  },\n\n  async resolve(_parent, {\n    user\n  }, {\n    prisma\n  }) {\n    if (!user) {\n      return handleError(errors.serverError);\n    }\n\n    const {\n      username,\n      email,\n      password,\n      passwordConfirm\n    } = user;\n\n    if (password.length < 8) {\n      return handleError(errors.passwordTooShort);\n    }\n\n    if (username.length < 2) {\n      return handleError(errors.usernameTooShort);\n    }\n\n    if (password !== passwordConfirm) {\n      return handleError(errors.passwordsMismatch);\n    }\n\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const createdUser = await prisma.user.create({\n      data: {\n        email,\n        username,\n        password: hashedPassword\n      }\n    });\n\n    if (!createdUser) {\n      return handleError(errors.serverError);\n    }\n\n    return {\n      user: createdUser,\n      token: generateAccessToken(createdUser.id)\n    };\n  }\n\n});\nexport const login = mutationField('login', {\n  type: 'AuthPayload',\n  args: {\n    email: stringArg({\n      nullable: false\n    }),\n    password: stringArg({\n      nullable: false\n    })\n  },\n\n  async resolve(_parent, {\n    email,\n    password\n  }, {\n    prisma\n  }) {\n    const user = await prisma.user.findOne({\n      where: {\n        email\n      }\n    });\n\n    if (!user) {\n      return handleError(errors.invalidUser);\n    }\n\n    const passwordValid = await bcrypt.compare(password, user.password);\n\n    if (!passwordValid) {\n      return handleError(errors.invalidUser);\n    }\n\n    return {\n      user,\n      token: generateAccessToken(user.id)\n    };\n  }\n\n});","map":{"version":3,"sources":["/Users/milosdzeletovic/projects/me/dnd-armory/dnd-armory-next/server/types/resolvers/mutations/auth.ts"],"names":["mutationField","stringArg","bcrypt","errors","handleError","generateAccessToken","signup","type","args","user","resolve","_parent","prisma","serverError","username","email","password","passwordConfirm","length","passwordTooShort","usernameTooShort","passwordsMismatch","hashedPassword","hash","createdUser","create","data","token","id","login","nullable","findOne","where","invalidUser","passwordValid","compare"],"mappings":"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","sourcesContent":["import { mutationField, stringArg } from '@nexus/schema'\nimport bcrypt from 'bcryptjs'\n\nimport errors from '../../../utils/errors'\nimport { handleError } from '../../../utils/helpers'\n\nimport { generateAccessToken } from '../../../utils/helpers'\n\nexport const signup = mutationField('signup', {\n  type: 'AuthPayload',\n  args: {\n    user: 'UserCreateInput',\n  },\n  async resolve(_parent, { user }, { prisma }) {\n    if (!user) {\n      return handleError(errors.serverError)\n    }\n\n    const { username, email, password, passwordConfirm } = user\n\n    if (password.length < 8) {\n      return handleError(errors.passwordTooShort)\n    }\n\n    if (username.length < 2) {\n      return handleError(errors.usernameTooShort)\n    }\n\n    if (password !== passwordConfirm) {\n      return handleError(errors.passwordsMismatch)\n    }\n\n    const hashedPassword: string = await bcrypt.hash(password, 10)\n\n    const createdUser = await prisma.user.create({\n      data: {\n        email,\n        username,\n        password: hashedPassword,\n      },\n    })\n\n    if (!createdUser) {\n      return handleError(errors.serverError)\n    }\n\n    return {\n      user: createdUser,\n      token: generateAccessToken(createdUser.id),\n    }\n  },\n})\n\nexport const login = mutationField('login', {\n  type: 'AuthPayload',\n  args: {\n    email: stringArg({ nullable: false }),\n    password: stringArg({ nullable: false }),\n  },\n  async resolve(_parent, { email, password }, { prisma }) {\n    const user = await prisma.user.findOne({\n      where: {\n        email,\n      },\n    })\n\n    if (!user) {\n      return handleError(errors.invalidUser)\n    }\n\n    const passwordValid = await bcrypt.compare(password, user.password)\n\n    if (!passwordValid) {\n      return handleError(errors.invalidUser)\n    }\n\n    return {\n      user,\n      token: generateAccessToken(user.id),\n    }\n  },\n})\n"]},"metadata":{},"sourceType":"module"}